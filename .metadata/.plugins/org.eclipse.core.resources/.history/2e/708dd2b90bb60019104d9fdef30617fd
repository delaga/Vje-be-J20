import stanford.karel.Karel;
import stanford.karel.SuperKarel;

// student version

public class SteepleChase extends Karel implements Directions 
{	

	// constructor
	// SteepleChase extends Robot, and the call to "super"
	// uses Robot's constructor
	public SteepleChase(int Street, int Avenue, Direction direction, int numberOfBeepers) 
    { super(Street, Avenue, direction, numberOfBeepers); 
    } 
	
	// shorter version of "putBeeper()" 
	// saves on typing
	public void pb()
	{	putBeeper();
	}
	
	public void tl()
	{	turnLeft();
	}

	public void tr()
	{ 	turnLeft();turnLeft();turnLeft();
	}
	
	public void m()
	{	move();
	}
	
	/*
	This method determines if it would be safe for Karel
	to turn right and move
	Use the boolean method 'frontIsClear()' here
	'frontIsClear()' is true only if the intersection
	just ahead of Karel is open
	This method should not change Karel's status at all
	It should only report 'true' or 'false' (in a return
	statement) on whether the right is clear
	*/
	public boolean rightIsClear()
	{	
	
	}
		
	/*
	This method is a heavy-lifter: it gets Karel to jump all the hurdles
	You want all the code in the method to be inside a WHILE loop
	that says 'while Karel is not next to a beeper, run the
	code inside this loop'
	You can use the boolean method 'nextToABeeper()'
	I find it helpful to think not so much about jumping hurdles
	but about 'hugging' the wall as Karel moves through the world
	If Karel hugs the wall he jumps all the hurdles successfully
	You can think of the hurdles as part of the wall he hugs
	You will probably use an IF - ELSE IF - ELSE structure inside
	the WHILE loop to handle different situations
	*/
	public void jumpHurdles()
	{	
			
	}
		
	public static void main(String [] args)
	{	World.setSize(15, 25);
		World.setVisible(true);
		World.setDelay(1);
		World.readWorld("your path/steeple.kwld");
		SteepleChase yourRobotName = new SteepleChase(1,1,East,0);
		yourRobotName.jumpHurdles();
		yourRobotName.turnOff();
	}
}

